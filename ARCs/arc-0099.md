---
arc: <to be assigned>
title: Implicit Transaction Negotiation
description: Allow signers to modify transactions before signing.
author: Steve Ferrigno (@nullun)
discussions-to: <URL>
status: Draft
type: Standards Track
category: Interface
subcategory: Wallet
created: 2025-11-22
---

## Abstract

This document aims to establish a standard way for two or more parties to review, modify, and accept transactions which may have been altered from their original form.

## Overview

Implicit Transaction Negotiation (ITN) is a convention to allow signers to modify transactions before signing. This protocol is stateless. The transaction group itself carries all necessary context. A dApp does not need to store a record of the initial transaction(s) to accept a valid counter-proposal.

ITN is a singular concept, designed to accommodate at least two different scenarios.

1. A dApp provides a transaction or atomic group to a user to review and sign. The user wants to modify one or more fields before signing.
2. Multiple users or agents are coordinating transaction signing of a transaction or atomic group. After the initial proposal is presented, each party takes it in turn to make changes before all transactions are signed.

## Rationale

Signers should have the ability to modify transactions that are presented to them before they sign, rather than having to accept defaults another party thinks they should accept. Two examples of this are the `fee` field and the `lv` (last valid) field.

The `fee` field, along with `tip` and `rf` (refundable fee) are likely to be frequently changing depending on network congestion. So a wallet would be able to provide a more accurate value immediately before signing. Alternatively a signer **MAY** choose to decrease their `lv` round, so they can guarantee if the transaction hasn't been included in a block by then, there's no risk by signing a new similar transaction.

## Terminology

Below is a list of terminologies used in this document.

* Volatile: A transaction or field that **MAY** change.
* Invariant: A transaction or field that **MUST NOT** change.

## Lifecycle

The negotiation is a stateless, recursive cycle, that continues until all transactions are signed or a rejected state is reached.

1. **PROPOSE**: Initiator sends a set of unsigned transactions (atomic group or single).
2. **REVIEW**: Receiver reviews the transaction group, identifying and categorising transactions and fields as either "volatile" or "invariant".
  1. All volatile elements **MUST** be assessed to determine if they're acceptable or require modification.
  2. All invariant elements **MUST** be acceptable as they are, otherwise the proposal **SHOULD** be rejected.
  3. If all elements are acceptable, proceed to **SIGN**.
3. **MODIFY**: Receiver **SHOULD** modify any volatile fields they consider unacceptable.
4. **PREPARE**: After a transaction has been modified, the modifier **MUST** remove all signatures and recalculate the `grp` (group ID) for all transactions.
5. **SIGN**: Receiver **MUST** now sign the transactions they are a signer for, indicating their willingness to proceed with the new transaction(s).
6. **RETURN**: The transactions are returned, enabling another party to re-enter **REVIEW** and continue the cycle.
7. **SUBMIT**: Once all transactions have signatures, the initiator **SHOULD** broadcast them to the network.

## Examples

### Permissioned dApp

1. dAppX sends Alice `[TxA, TxB]`.
2. Alice checks invariants. Checks volatiles, changes fee. GroupID changes. Signs `TxB`. Returns `[TxA (unsigned), TxB (signed)]`.
3. dAppX checks invariants. Doesn't have or ignores volatiles. Signs `TxA`. All transactions signed. Submits.

### Agent-to-Agent Exchange

1. Agent1 sends Agent2 `[10 USDC (signed), 1 NFT (unsigned)]`.
2. Agent2 checks invariants. Checks volatiles, changes USDC amount. GroupID changes. Signs NFT transaction. Returns `[20 USDC (unsigned), 1 NFT (signed)]`.
3. Agent1 checks invariants. Checks volatiles, changes USDC amount. GroupID changes. Signs USDC transaction. Returns `[15 USDC (signed), 1 NFT (unsigned)]`.
4. Agent2 checks invariants. Checks volatiles. Signs NFT transaction. Returns `[15 USDC (signed), 1 NFT (signed)]`.
5. Agent1 checks invariants. Checks volatiles. All transactions signed. Submits.

##  Backwards Compatibility

Since no data structures are changing and it is the transactions with their signatures which ultimately indicate a participants agreement with a change, the act of changing a field and therefore its `txid` (transaction ID) implies a negotiation is underway. Meaning any platform, wallet, or other interface that doesn't support this standard **SHOULD** automatically treat every transaction and field as an invariant, immediately rejecting any attempt at modifying the transactions.

## Security Considerations

### Stateless Validation

Implementers **SHOULD NOT** rely on stored session state to validate the transactions. Instead validation should be performed _de novo_ on the payload. The dApp or Wallet should simply ask: "Does this incoming transaction group satisfy my business constraints?" regardless of whether it matches the exact binary that was originally sent.

### Invariant Checks

The general approach to transaction signing prior to this document has been to rely on the `txid` as a proxy for validity. Under ITN, the Hash is volatile. Therefore, any dApp, Wallet, or other interface **MUST** treat a returned, modified transaction group as untrusted input. Before adding their own signature, they **MUST** explicitly (re)validate all invariant fields (Amounts, Receivers, AppArgs) to ensure the counter-party did not slip in a malicious change alongside a legitimate fee adjustment.

## Additional Comments

A frontend **MAY** be interested in the transaction IDs to inform the user if/when their transactions are committed to the chain. It may also be used to read the apply data fields (`log`, etc) of specific evaluated transactions. However libraries such as [algokit-subscriber-ts](https://github.com/algorandfoundation/algokit-subscriber-ts) help tremendously in monitoring for domain specific transactions regardless of knowing the transaction ID in advance. Instead a frontend could display all on-chain interactions for a user based on their connected wallet address alone.

## Copyright
Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CCO</a>.
